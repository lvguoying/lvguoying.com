<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一篇文章学会redux--基于reacr-redux]]></title>
    <url>%2F2018%2F10%2F20%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Aredux-%E5%9F%BA%E4%BA%8Ereacr-redux%2F</url>
    <content type="text"><![CDATA[Redux 简明教程 原文链接（保持更新）：https://github.com/lvguoying/redux-simple-tutorial 写在前面本教程深入浅出，配套 简明教程、进阶教程（源码精读）以及文档注释丰满的 Demo 等一条龙服务 &sect; 为什么要用 Redux 当然还有 Flux、Reflux、Mobx 等状态管理库可供选择抛开需求讲实用性都是耍流氓，因此下面由我扮演您那可亲可爱的产品经理 ⊙ 需求 1：在控制台上记录用户的每个动作不知道您是否有后端的开发经验，后端一般会有记录访问日志的中间件例如，在 Express 中实现一个简单的 Logger 如下： 123456var loggerMiddleware = function(req, res, next) &#123; console.log('[Logger]', req.method, req.originalUrl) next()&#125;...app.use(loggerMiddleware) 每次访问的时候，都会在控制台中留下类似下面的日志便于追踪调试： 1234[Logger] GET /[Logger] POST /login[Logger] GET /user?uid=10086... 如果我们把场景转移到前端，请问该如何实现用户的动作跟踪记录？我们可能会这样写： 123456789101112131415161718192021/** jQuery **/$('#loginBtn').on('click', function(e) &#123; console.log('[Logger] 用户登录') ...&#125;)$('#logoutBtn').on('click', function() &#123; console.log('[Logger] 用户退出登录') ...&#125;)/** MVC / MVVM 框架（这里以纯 Vue 举例） **/methods: &#123; handleLogin () &#123; console.log('[Logger] 用户登录') ... &#125;, handleLogout () &#123; console.log('[Logger] 用户退出登录') ... &#125;&#125; 上述 jQuery 与 MV* 的写法并没有本质上的区别记录用户行为代码的侵入性极强，可维护性与扩展性堪忧 ⊙ 需求 2：在上述需求的基础上，记录用户的操作时间 哼！最讨厌就是改需求了，这种简单的需求难道不是应该一开始就想好的吗？呵呵，如果每位产品经理都能一开始就把需求完善好，我们就不用加班了好伐 显然地，前端的童鞋又得一个一个去改（当然 编辑器 / IDE 都支持全局替换）：123456789101112131415161718192021/** jQuery **/$('#loginBtn').on('click', function(e) &#123; console.log('[Logger] 用户登录', new Date()) ...&#125;)$('#logoutBtn').on('click', function() &#123; console.log('[Logger] 用户退出登录', new Date()) ...&#125;)/** MVC / MVVM 框架（这里以 Vue 举例） **/methods: &#123; handleLogin () &#123; console.log('[Logger] 用户登录', new Date()) ... &#125;, handleLogout () &#123; console.log('[Logger] 用户退出登录', new Date()) ... &#125;&#125; 而后端的童鞋只需要稍微修改一下原来的中间件即可： 123456var loggerMiddleware = function(req, res, next) &#123; console.log('[Logger]', new Date(), req.method, req.originalUrl) next()&#125;...app.use(loggerMiddleware) ⊙ 需求 3：正式上线的时候，把控制台中有关 Logger 的输出全部去掉难道您以为有了 UglifyJS，配置一个 drop_console: true 就好了吗？图样图森破，拿衣服！请看清楚了，仅仅是去掉有关 Logger 的 console.log，其他的要保留哦亲~~~于是前端的童鞋又不得不乖乖地一个一个注释掉（当然也可以设置一个环境变量判断是否输出，甚至可以重写 console.log） 而我们后端的童鞋呢？只需要注释掉一行代码即可：// app.use(loggerMiddleware)，真可谓是不费吹灰之力 ⊙ 需求 4：正式上线后，自动收集 bug，并还原出当时的场景收集用户报错还是比较简单的，利用 window.error 事件，然后根据 Source Map 定位到源码（但一般查不出什么） 但要完全还原出当时的使用场景，几乎是不可能的。因为您不知道这个报错，用户是怎么一步一步操作得来的就算知道用户是如何操作得来的，但在您的电脑上，测试永远都是通过的（不是我写的程序有问题，是用户用的方式有问题） 相对地，后端的报错的收集、定位以及还原却是相当简单。只要一个 API 有 bug，那无论用什么设备访问，都会得到这个 bug还原 bug 也是相当简单：把数据库备份导入到另一台机器，部署同样的运行环境与代码。如无意外，bug 肯定可以完美重现 在这个问题上拿后端跟前端对比，确实有失公允。但为了鼓吹 Redux 的优越，只能勉为其难了 实际上 jQuery / MV* 中也能实现用户动作的跟踪，用一个数组往里面 push 用户动作即可但这样操作的意义不大，因为仅仅只有动作，无法反映动作前后，应用状态的变动情况 ※ 小结为何前后端对于这类需求的处理竟然大相径庭？后端为何可以如此优雅？原因在于，后端具有统一的入口与统一的状态管理（数据库），因此可以引入中间件机制来统一实现某些功能 多年来，前端工程师忍辱负重，操着卖白粉的心，赚着买白菜的钱，一直处于程序员鄙视链的底层于是有大牛就把后端 MVC 的开发思维搬到前端，将应用中所有的动作与状态都统一管理，让一切有据可循 使用 Redux，借助 Redux DevTools 可以实现出“华丽如时光旅行一般的调试效果”实际上就是开发调试过程中可以撤销与重做，并且支持应用状态的导入和导出（就像是数据库的备份）而且，由于可以使用日志完整记录下每个动作，因此做到像 Git 般，随时随地恢复到之前的状态 由于可以导出和导入应用的状态（包括路由状态），因此还可以实现前后端同构（服务端渲染）当然，既然有了动作日志以及动作前后的状态备份，那么还原用户报错场景还会是一个难题吗？ &sect; Store首先要区分 store 和 state state 是应用的状态，一般本质上是一个普通对象例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）： 12345/** 应用初始 state，本代码块记为 code-1 **/&#123; counter: 0, todos: []&#125; store 是应用状态 state 的管理者，包含下列四个函数： getState() # 获取整个 state dispatch(action) # ※ 触发 state 改变的【唯一途径】※ subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用 二者的关系是：state = store.getState() Redux 规定，一个应用只应有一个单一的 store，其管理着唯一的应用状态 stateRedux 还规定，不能直接修改应用的状态 state，也就是说，下面的行为是不允许的： 12var state = store.getState()state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state 若要改变 state，必须 dispatch 一个 action，这是修改应用状态的不二法门 现在您只需要记住 action 只是一个包含 type 属性的普通对象即可例如 { type: &#39;INCREMENT&#39; } 上面提到，state 是通过 store.getState() 获取，那么 store 又是怎么来的呢？想生成一个 store，我们需要调用 Redux 的 createStore： 123456789101112131415161718192021import &#123; createStore &#125; from 'redux'...const store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！``` &gt; 现在您只需要记住 `reducer` 是一个 **函数**，负责**更新**并返回一个**新的** `state` &gt; 而 `initialState` 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染） ## &amp;sect; Action上面提到，`action`（动作）实质上是包含 `type` 属性的普通对象，这个 `type` 是我们实现用户行为追踪的关键 例如，增加一个待办事项 的 `action` 可能是像下面一样：```js/** 本代码块记为 code-2 **/&#123; type: 'ADD_TODO', payload: &#123; id: 1, content: '待办事项1', completed: false &#125;&#125; 当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了也就是说，下面这些 action 都是合法的： 12345678910111213141516/** 如下都是合法的，但就是不够规范 **/&#123; type: 'ADD_TODO', id: 1, content: '待办事项1', completed: false&#125;&#123; type: 'ADD_TODO', abcdefg: &#123; id: 1, content: '待办事项1', completed: false &#125;&#125; 虽说没有约束，但最好还是遵循规范 如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）： 123456789/** 本代码块记为 code-3 **/&#123; counter: 0, todos: [&#123; id: 1, content: '待办事项1', completed: false &#125;]&#125; 刨根问底，action 是谁生成的呢？ ⊙ Action Creator Action Creator 可以是同步的，也可以是异步的 顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）例如下面就是一个 “新增一个待办事项” 的 Action Creator： 123456789101112/** 本代码块记为 code-4 **/var id = 1function addTodo(content) &#123; return &#123; type: 'ADD_TODO', payload: &#123; id: id++, content: content, // 待办事项内容 completed: false // 是否完成的标识 &#125; &#125;&#125; 将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）： 1234567891011&lt;--! 本代码块记为 code-5 --&gt;&lt;input type="text" id="todoInput" /&gt;&lt;button id="btn"&gt;提交&lt;/button&gt;&lt;script&gt;$('#btn').on('click', function() &#123; var content = $('#todoInput').val() // 获取输入框的值 var action = addTodo(content) // 执行 Action Creator 获得 action store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！&#125;)&lt;/script&gt; 在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了： 12345678910111213/** 本代码块记为 code-6 **/&#123; counter: 0, todos: [&#123; id: 1, content: '待办事项1', completed: false &#125;, &#123; id: 2, content: '待办事项2', completed: false &#125;]&#125; 通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action) 刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？又是谁负责“写入”的呢？悬念即将揭晓… &sect; Reducer Reducer 必须是同步的纯函数 用户每次 dispatch(action) 后，都会触发 reducer 的执行reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState最后会用 reducer 的返回值 nextState 完全替换掉原来的 state 注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ ... 等返回副本的函数 在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)： 12345678910111213141516171819202122/** 本代码块记为 code-7 **/var initState = &#123; counter: 0, todos: []&#125;function reducer(state, action) &#123; // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※ if (!state) state = initState switch (action.type) &#123; case 'ADD_TODO': var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆 nextState.todos.push(action.payload) return nextState default: // 由于 nextState 会把原 state 整个替换掉 // 若无修改，必须返回原 state（否则就是 undefined） return state &#125;&#125; 通俗点讲，就是 reducer 返回啥，state 就被替换成啥 &sect; 总结 store 由 Redux 的 createStore(reducer) 生成 state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象 action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生 改变 state 必须 dispatch 一个 action reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数 reducer 必须返回值，否则 nextState 即为 undefined 实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单） Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState ⊙ Redux 与传统后端 MVC 的对照 Redux 传统后端 MVC store 数据库实例 state 数据库中存储的数据 dispatch(action) 用户发起请求 action: { type, payload } type 表示请求的 URL，payload 表示请求的数据 reducer 路由 + 控制器（handler） reducer 中的 switch-case 分支 路由，根据 action.type 路由到对应的控制器 reducer 内部对 state 的处理 控制器对数据库进行增删改操作 reducer 返回 nextState 将修改后的记录写回数据库 &sect; 最简单的例子 ( 在线演示 )1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="//cdn.bootcss.com/redux/3.5.2/redux.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;/** Action Creators */function inc() &#123; return &#123; type: 'INCREMENT' &#125;;&#125;function dec() &#123; return &#123; type: 'DECREMENT' &#125;;&#125;function reducer(state, action) &#123; // 首次调用本函数时设置初始 state state = state || &#123; counter: 0 &#125;; switch (action.type) &#123; case 'INCREMENT': return &#123; counter: state.counter + 1 &#125;; case 'DECREMENT': return &#123; counter: state.counter - 1 &#125;; default: return state; // 无论如何都返回一个 state &#125;&#125;var store = Redux.createStore(reducer);console.log( store.getState() ); // &#123; counter: 0 &#125;store.dispatch(inc());console.log( store.getState() ); // &#123; counter: 1 &#125;store.dispatch(inc());console.log( store.getState() ); // &#123; counter: 2 &#125;store.dispatch(dec());console.log( store.getState() ); // &#123; counter: 1 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 由上可知，Redux 并不一定要搭配 React 使用。Redux 纯粹只是一个状态管理库，几乎可以搭配任何框架使用（上述例子连 jQuery 都没用哦亲） &sect; 下一章：Redux 进阶教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 介绍]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[这是篇对Hexo博客的编写，部署，设计的详细说明。 这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 一级标题二级标题三级标题四级标题五级标题六级标题行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-简书[1]:https://www/lvguoying.com/ 自动链接：我的博客地址https://www/lvguoying.com/ 无序列表项1 无序列表项2 无序列表项3 在 Hexo 中插入图片，首先需要将图片放在 source/images/ 文件夹下，然后如下方式进行插入： 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐]]></content>
      <categories>
        <category>常事</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇Hexo博客，写点vue的基础环境安装]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%88%91%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-mac%E4%B8%8A%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言通过近来对多人的面试，发现大部分 vue开发者 只停留在代码搬运阶段，而对概念和实现原理一知半解，特用此文档，将 vue.js 高频面试题从 代码实现 到 原理分析 进行整理、解析。本文档也不仅仅限于vue前端面试使用，而是以vue实际开发遇到的问题为出发点，带你关注 vue开发 过程中需要注意的一个个知识点。也希望可以帮助您解决vue实际开发过程中的问题。 一.vue-cli依赖的 Node.js 环境安装下面介绍 Node.js 环境的安装：1、首先需要在 node.js 官网: node.js .下载下载对应的 Node 环境安装包。 2、然后打开安装包，一直点击 next 3、测试安装成功 打开 cmd 命令行，命令行输入：1node -v 出现版本号，说明可以使用 node 的包管理器 npm，下载资源包。 二、vue-cli 工程技术集合介绍问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么?1、vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。2、vue-router：vue官方推荐使用的路由框架。3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。5、vux等：一个专为vue设计的移动端UI组件库。6、创建一个emit.js文件，用于vue事件机制的管理。7、webpack：模块加载和vue-cli工程打包器。 问题二：vue-cli 工程常用的 npm 命令有哪些？下载 node_modules 资源包的命令1npm install 启动 vue-cli 开发环境的 npm命令：1npm run dev vue-cli 生成 生产环境部署资源 的 npm命令：1npm run build 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：1npm run build --report 此命令必答，可以加深面试官好感！ 三、vue-cli 工程目录结构介绍问题一：请说出vue-cli工程中每个文件夹和文件的用处(注意：此问题千万不要只解释一下 src 文件夹下每个文件夹的作用。) vue-cli目录解析：1.build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。2.config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。3.dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。4.node_modules：存放npm命令下载的开发环境和生产环境的依赖包。5.src: 存放项目源码及需要引用的资源文件。6.src下assets：存放项目中需要用到的资源文件，css、js、images等。7.src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。8.src下emit：自己配置的vue集中式事件管理机制。9.src下router：vue-router vue路由的配置文件。10.src下service：自己配置的vue请求后台接口方法。11.src下page：存在vue页面组件的文件夹。12.src下util：存放vue开发过程中一些公共的.js方法。13.src下vuex：存放 vuex 为vue专门开发的状态管理器。14.src下app.vue：使用标签&lt;route-view&gt;&lt;/router-view&gt;渲染整个工程的.vue组件。15.src下main.js：vue-cli工程的入口文件。16.index.html：设置项目的一些meta头信息和提供&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;用于挂载 vue 节点。17.package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。 问题二：config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置build 对象下 对于 生产环境 的配置： index：配置打包后入口.html文件的名称以及文件夹名称 assetsRoot：配置打包后生成的文件名称和路径 assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 “./“ productionGzip：是否开发 gzip 压缩，以提升加载速度 dev 对象下 对于 开发环境 的配置： port：设置端口号 autoOpenBrowser：启动工程时，自动打开浏览器 proxyTable：vue设置的代理，用以解决 跨域 问题 问题三：请你详细介绍一些 package.json 里面的配置 scripts：npm run xxx 命令调用node执行的 .js 文件 dependencies：生产环境依赖包的名称和版本号，即这些依赖包都会打包进生产环境的JS文件里面 devDependencies：开发环境依赖包的名称和版本号，即这些依赖包只用于代码开发的时候，不会打包进生产环境js文件里面。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
