<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一篇文章学会redux--基于reacr-redux]]></title>
    <url>%2F2018%2F10%2F20%2F%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9Aredux-%E5%9F%BA%E4%BA%8Ereacr-redux%2F</url>
    <content type="text"><![CDATA[Redux 简明教程 原文链接（保持更新）：https://github.com/lvguoying/redux-simple-tutorial 写在前面本教程深入浅出，配套 简明教程、进阶教程（源码精读）以及文档注释丰满的 Demo 等一条龙服务 &sect; 为什么要用 Redux 当然还有 Flux、Reflux、Mobx 等状态管理库可供选择抛开需求讲实用性都是耍流氓，因此下面由我扮演您那可亲可爱的产品经理 ⊙ 需求 1：在控制台上记录用户的每个动作不知道您是否有后端的开发经验，后端一般会有记录访问日志的中间件例如，在 Express 中实现一个简单的 Logger 如下： 123456var loggerMiddleware = function(req, res, next) &#123; console.log('[Logger]', req.method, req.originalUrl) next()&#125;...app.use(loggerMiddleware) 每次访问的时候，都会在控制台中留下类似下面的日志便于追踪调试： 1234[Logger] GET /[Logger] POST /login[Logger] GET /user?uid=10086... 如果我们把场景转移到前端，请问该如何实现用户的动作跟踪记录？我们可能会这样写： 123456789101112131415161718192021/** jQuery **/$('#loginBtn').on('click', function(e) &#123; console.log('[Logger] 用户登录') ...&#125;)$('#logoutBtn').on('click', function() &#123; console.log('[Logger] 用户退出登录') ...&#125;)/** MVC / MVVM 框架（这里以纯 Vue 举例） **/methods: &#123; handleLogin () &#123; console.log('[Logger] 用户登录') ... &#125;, handleLogout () &#123; console.log('[Logger] 用户退出登录') ... &#125;&#125; 上述 jQuery 与 MV* 的写法并没有本质上的区别记录用户行为代码的侵入性极强，可维护性与扩展性堪忧 ⊙ 需求 2：在上述需求的基础上，记录用户的操作时间 哼！最讨厌就是改需求了，这种简单的需求难道不是应该一开始就想好的吗？呵呵，如果每位产品经理都能一开始就把需求完善好，我们就不用加班了好伐 显然地，前端的童鞋又得一个一个去改（当然 编辑器 / IDE 都支持全局替换）：123456789101112131415161718192021/** jQuery **/$('#loginBtn').on('click', function(e) &#123; console.log('[Logger] 用户登录', new Date()) ...&#125;)$('#logoutBtn').on('click', function() &#123; console.log('[Logger] 用户退出登录', new Date()) ...&#125;)/** MVC / MVVM 框架（这里以 Vue 举例） **/methods: &#123; handleLogin () &#123; console.log('[Logger] 用户登录', new Date()) ... &#125;, handleLogout () &#123; console.log('[Logger] 用户退出登录', new Date()) ... &#125;&#125; 而后端的童鞋只需要稍微修改一下原来的中间件即可： 123456var loggerMiddleware = function(req, res, next) &#123; console.log('[Logger]', new Date(), req.method, req.originalUrl) next()&#125;...app.use(loggerMiddleware) ⊙ 需求 3：正式上线的时候，把控制台中有关 Logger 的输出全部去掉难道您以为有了 UglifyJS，配置一个 drop_console: true 就好了吗？图样图森破，拿衣服！请看清楚了，仅仅是去掉有关 Logger 的 console.log，其他的要保留哦亲~~~于是前端的童鞋又不得不乖乖地一个一个注释掉（当然也可以设置一个环境变量判断是否输出，甚至可以重写 console.log） 而我们后端的童鞋呢？只需要注释掉一行代码即可：// app.use(loggerMiddleware)，真可谓是不费吹灰之力 ⊙ 需求 4：正式上线后，自动收集 bug，并还原出当时的场景收集用户报错还是比较简单的，利用 window.error 事件，然后根据 Source Map 定位到源码（但一般查不出什么） 但要完全还原出当时的使用场景，几乎是不可能的。因为您不知道这个报错，用户是怎么一步一步操作得来的就算知道用户是如何操作得来的，但在您的电脑上，测试永远都是通过的（不是我写的程序有问题，是用户用的方式有问题） 相对地，后端的报错的收集、定位以及还原却是相当简单。只要一个 API 有 bug，那无论用什么设备访问，都会得到这个 bug还原 bug 也是相当简单：把数据库备份导入到另一台机器，部署同样的运行环境与代码。如无意外，bug 肯定可以完美重现 在这个问题上拿后端跟前端对比，确实有失公允。但为了鼓吹 Redux 的优越，只能勉为其难了 实际上 jQuery / MV* 中也能实现用户动作的跟踪，用一个数组往里面 push 用户动作即可但这样操作的意义不大，因为仅仅只有动作，无法反映动作前后，应用状态的变动情况 ※ 小结为何前后端对于这类需求的处理竟然大相径庭？后端为何可以如此优雅？原因在于，后端具有统一的入口与统一的状态管理（数据库），因此可以引入中间件机制来统一实现某些功能 多年来，前端工程师忍辱负重，操着卖白粉的心，赚着买白菜的钱，一直处于程序员鄙视链的底层于是有大牛就把后端 MVC 的开发思维搬到前端，将应用中所有的动作与状态都统一管理，让一切有据可循 使用 Redux，借助 Redux DevTools 可以实现出“华丽如时光旅行一般的调试效果”实际上就是开发调试过程中可以撤销与重做，并且支持应用状态的导入和导出（就像是数据库的备份）而且，由于可以使用日志完整记录下每个动作，因此做到像 Git 般，随时随地恢复到之前的状态 由于可以导出和导入应用的状态（包括路由状态），因此还可以实现前后端同构（服务端渲染）当然，既然有了动作日志以及动作前后的状态备份，那么还原用户报错场景还会是一个难题吗？ &sect; Store首先要区分 store 和 state state 是应用的状态，一般本质上是一个普通对象例如，我们有一个 Web APP，包含 计数器 和 待办事项 两大功能那么我们可以为该应用设计出对应的存储数据结构（应用初始状态）： 12345/** 应用初始 state，本代码块记为 code-1 **/&#123; counter: 0, todos: []&#125; store 是应用状态 state 的管理者，包含下列四个函数： getState() # 获取整个 state dispatch(action) # ※ 触发 state 改变的【唯一途径】※ subscribe(listener) # 您可以理解成是 DOM 中的 addEventListener replaceReducer(nextReducer) # 一般在 Webpack Code-Splitting 按需加载的时候用 二者的关系是：state = store.getState() Redux 规定，一个应用只应有一个单一的 store，其管理着唯一的应用状态 stateRedux 还规定，不能直接修改应用的状态 state，也就是说，下面的行为是不允许的： 12var state = store.getState()state.counter = state.counter + 1 // 禁止在业务逻辑中直接修改 state 若要改变 state，必须 dispatch 一个 action，这是修改应用状态的不二法门 现在您只需要记住 action 只是一个包含 type 属性的普通对象即可例如 { type: &#39;INCREMENT&#39; } 上面提到，state 是通过 store.getState() 获取，那么 store 又是怎么来的呢？想生成一个 store，我们需要调用 Redux 的 createStore： 123456789101112131415161718192021import &#123; createStore &#125; from 'redux'...const store = createStore(reducer, initialState) // store 是靠传入 reducer 生成的哦！``` &gt; 现在您只需要记住 `reducer` 是一个 **函数**，负责**更新**并返回一个**新的** `state` &gt; 而 `initialState` 主要用于前后端同构的数据同步（详情请关注 React 服务端渲染） ## &amp;sect; Action上面提到，`action`（动作）实质上是包含 `type` 属性的普通对象，这个 `type` 是我们实现用户行为追踪的关键 例如，增加一个待办事项 的 `action` 可能是像下面一样：```js/** 本代码块记为 code-2 **/&#123; type: 'ADD_TODO', payload: &#123; id: 1, content: '待办事项1', completed: false &#125;&#125; 当然，action 的形式是多种多样的，唯一的约束仅仅就是包含一个 type 属性罢了也就是说，下面这些 action 都是合法的： 12345678910111213141516/** 如下都是合法的，但就是不够规范 **/&#123; type: 'ADD_TODO', id: 1, content: '待办事项1', completed: false&#125;&#123; type: 'ADD_TODO', abcdefg: &#123; id: 1, content: '待办事项1', completed: false &#125;&#125; 虽说没有约束，但最好还是遵循规范 如果需要新增一个代办事项，实际上就是将 code-2 中的 payload “写入” 到 state.todos 数组中（如何“写入”？在此留个悬念）： 123456789/** 本代码块记为 code-3 **/&#123; counter: 0, todos: [&#123; id: 1, content: '待办事项1', completed: false &#125;]&#125; 刨根问底，action 是谁生成的呢？ ⊙ Action Creator Action Creator 可以是同步的，也可以是异步的 顾名思义，Action Creator 是 action 的创造者，本质上就是一个函数，返回值是一个 action（对象）例如下面就是一个 “新增一个待办事项” 的 Action Creator： 123456789101112/** 本代码块记为 code-4 **/var id = 1function addTodo(content) &#123; return &#123; type: 'ADD_TODO', payload: &#123; id: id++, content: content, // 待办事项内容 completed: false // 是否完成的标识 &#125; &#125;&#125; 将该函数应用到一个表单（假设 store 为全局变量，并引入了 jQuery ）： 1234567891011&lt;--! 本代码块记为 code-5 --&gt;&lt;input type="text" id="todoInput" /&gt;&lt;button id="btn"&gt;提交&lt;/button&gt;&lt;script&gt;$('#btn').on('click', function() &#123; var content = $('#todoInput').val() // 获取输入框的值 var action = addTodo(content) // 执行 Action Creator 获得 action store.dispatch(action) // 改变 state 的不二法门：dispatch 一个 action！！！&#125;)&lt;/script&gt; 在输入框中输入 “待办事项2” 后，点击一下提交按钮，我们的 state 就变成了： 12345678910111213/** 本代码块记为 code-6 **/&#123; counter: 0, todos: [&#123; id: 1, content: '待办事项1', completed: false &#125;, &#123; id: 2, content: '待办事项2', completed: false &#125;]&#125; 通俗点讲，Action Creator 用于绑定到用户的操作（点击按钮等），其返回值 action 用于之后的 dispatch(action) 刚刚提到过，action 明明就没有强制的规范，为什么 store.dispatch(action) 之后，Redux 会明确知道是提取 action.payload，并且是对应写入到 state.todos 数组中？又是谁负责“写入”的呢？悬念即将揭晓… &sect; Reducer Reducer 必须是同步的纯函数 用户每次 dispatch(action) 后，都会触发 reducer 的执行reducer 的实质是一个函数，根据 action.type 来更新 state 并返回 nextState最后会用 reducer 的返回值 nextState 完全替换掉原来的 state 注意：上面的这个 “更新” 并不是指 reducer 可以直接对 state 进行修改Redux 规定，须先复制一份 state，在副本 nextState 上进行修改操作例如，可以使用 lodash 的 cloneDeep，也可以使用 Object.assign / map / filter/ ... 等返回副本的函数 在上面 Action Creator 中提到的 待办事项的 reducer 大概是长这个样子 (为了容易理解，在此不使用 ES6 / Immutable.js)： 12345678910111213141516171819202122/** 本代码块记为 code-7 **/var initState = &#123; counter: 0, todos: []&#125;function reducer(state, action) &#123; // ※ 应用的初始状态是在第一次执行 reducer 时设置的 ※ if (!state) state = initState switch (action.type) &#123; case 'ADD_TODO': var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆 nextState.todos.push(action.payload) return nextState default: // 由于 nextState 会把原 state 整个替换掉 // 若无修改，必须返回原 state（否则就是 undefined） return state &#125;&#125; 通俗点讲，就是 reducer 返回啥，state 就被替换成啥 &sect; 总结 store 由 Redux 的 createStore(reducer) 生成 state 通过 store.getState() 获取，本质上一般是一个存储着整个应用状态的对象 action 本质上是一个包含 type 属性的普通对象，由 Action Creator (函数) 产生 改变 state 必须 dispatch 一个 action reducer 本质上是根据 action.type 来更新 state 并返回 nextState 的函数 reducer 必须返回值，否则 nextState 即为 undefined 实际上，state 就是所有 reducer 返回值的汇总（本教程只有一个 reducer，主要是应用场景比较简单） Action Creator =&gt; action =&gt; store.dispatch(action) =&gt; reducer(state, action) =&gt; 原 state state = nextState ⊙ Redux 与传统后端 MVC 的对照 Redux 传统后端 MVC store 数据库实例 state 数据库中存储的数据 dispatch(action) 用户发起请求 action: { type, payload } type 表示请求的 URL，payload 表示请求的数据 reducer 路由 + 控制器（handler） reducer 中的 switch-case 分支 路由，根据 action.type 路由到对应的控制器 reducer 内部对 state 的处理 控制器对数据库进行增删改操作 reducer 返回 nextState 将修改后的记录写回数据库 &sect; 最简单的例子 ( 在线演示 )1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="//cdn.bootcss.com/redux/3.5.2/redux.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;/** Action Creators */function inc() &#123; return &#123; type: 'INCREMENT' &#125;;&#125;function dec() &#123; return &#123; type: 'DECREMENT' &#125;;&#125;function reducer(state, action) &#123; // 首次调用本函数时设置初始 state state = state || &#123; counter: 0 &#125;; switch (action.type) &#123; case 'INCREMENT': return &#123; counter: state.counter + 1 &#125;; case 'DECREMENT': return &#123; counter: state.counter - 1 &#125;; default: return state; // 无论如何都返回一个 state &#125;&#125;var store = Redux.createStore(reducer);console.log( store.getState() ); // &#123; counter: 0 &#125;store.dispatch(inc());console.log( store.getState() ); // &#123; counter: 1 &#125;store.dispatch(inc());console.log( store.getState() ); // &#123; counter: 2 &#125;store.dispatch(dec());console.log( store.getState() ); // &#123; counter: 1 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 由上可知，Redux 并不一定要搭配 React 使用。Redux 纯粹只是一个状态管理库，几乎可以搭配任何框架使用（上述例子连 jQuery 都没用哦亲） &sect; 下一章：Redux 进阶教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 进阶 教程]]></title>
    <url>%2F2018%2F10%2F20%2Freact%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Redux 进阶教程 原文（保持更新）：https://github.com/kenberkeley/redux-simple-tutorial 写在前面相信您已经看过 Redux 简明教程，本教程是简明教程的实战化版本，伴随源码分析Redux 用的是 ES6 编写，看到有疑惑的地方的，可以复制粘贴到这里在线编译 ES5 &sect; Redux API 总览在 Redux 的源码目录 src/，我们可以看到如下文件结构： 12345678├── utils/│ ├── warning.js # 打酱油的，负责在控制台显示警告信息├── applyMiddleware.js├── bindActionCreators.js├── combineReducers.js├── compose.js├── createStore.js├── index.js # 入口文件 除去打酱油的 utils/warning.js 以及入口文件 index.js，剩下那 5 个就是 Redux 的 API &sect; compose(…functions) 先说这个 API 的原因是它没有依赖，是一个纯函数 ⊙ 源码分析1234567891011121314151617181920212223/** * 看起来逼格很高，实际运用其实是这样子的： * compose(f, g, h)(...arg) =&gt; f(g(h(...args))) * * 值得注意的是，它用到了 reduceRight，因此执行顺序是从右到左 * * @param &#123;多个函数，用逗号隔开&#125; * @return &#123;函数&#125; */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; 这里的关键点在于，reduceRight 可传入初始值： 123456789101112// 由于 reduce / reduceRight 仅仅是方向的不同，因此下面用 reduce 说明即可var arr = [1, 2, 3, 4, 5]var re1 = arr.reduce(function(total, i) &#123; return total + i&#125;)console.log(re1) // 15var re2 = arr.reduce(function(total, i) &#123; return total + i&#125;, 100) // &lt;---------------传入一个初始值console.log(re2) // 115 下面是 compose 的实例（在线演示）： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="//cdn.bootcss.com/redux/3.5.2/redux.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function func1(num) &#123; console.log('func1 获得参数 ' + num); return num + 1;&#125;function func2(num) &#123; console.log('func2 获得参数 ' + num); return num + 2;&#125; function func3(num) &#123; console.log('func3 获得参数 ' + num); return num + 3;&#125;// 有点难看（如果函数名再长一点，那屏幕就不够宽了）var re1 = func3(func2(func1(0)));console.log('re1：' + re1);console.log('===============');// 很优雅var re2 = Redux.compose(func3, func2, func1)(0);console.log('re2：' + re2);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台输出： 123456789func1 获得参数 0func2 获得参数 1func3 获得参数 3re1：6===============func1 获得参数 0func2 获得参数 1func3 获得参数 3re2：6 &sect; createStore(reducer, initialState, enhancer)⊙ 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import isPlainObject from 'lodash/isPlainObject'import $$observable from 'symbol-observable'/** * 这是 Redux 的私有 action 常量 * 长得太丑了，你不要鸟就行了 */export var ActionTypes = &#123; INIT: '@@redux/INIT'&#125;/** * @param &#123;函数&#125; reducer 不多解释了 * @param &#123;对象&#125; preloadedState 主要用于前后端同构时的数据同步 * @param &#123;函数&#125; enhancer 很牛逼，可以实现中间件、时间旅行，持久化等 * ※ Redux 仅提供 applyMiddleware 这个 Store Enhancer ※ * @return &#123;Store&#125; */export default function createStore(reducer, preloadedState, enhancer) &#123; // 这里省略的代码，到本文的最后再讲述（用于压轴你懂的） var currentReducer = reducer var currentState = preloadedState // 这就是整个应用的 state var currentListeners = [] // 用于存储订阅的回调函数，dispatch 后逐个执行 var nextListeners = currentListeners //【悬念1：为什么需要两个 存放回调函数 的变量？】 var isDispatching = false /** * 【悬念1·解疑】 * 试想，dispatch 后，回调函数正在乖乖地被逐个执行（for 循环进行时） * 假设回调函数队列原本是这样的 [a, b, c, d] * * 现在 for 循环执行到第 3 步，亦即 a、b 已经被执行，准备执行 c * 但在这电光火石的瞬间，a 被取消订阅！！！ * * 那么此时回调函数队列就变成了 [b, c, d] * 那么第 3 步就对应换成了 d！！！ * c 被跳过了！！！这就是躺枪。。。 * * 作为一个回调函数，最大的耻辱就是得不到执行 * 因此为了避免这个问题，本函数会在上述场景中把 * currentListeners 复制给 nextListeners * * 这样的话，dispatch 后，在逐个执行回调函数的过程中 * 如果有新增订阅或取消订阅，都在 nextListeners 中操作 * 让 currentListeners 中的回调函数得以完整地执行 * * 既然新增是在 nextListeners 中 push，因此毫无疑问 * 新的回调函数不会在本次 currentListeners 的循环体中被触发 * * （上述事件发生的几率虽然很低，但还是严谨点比较好） */ function ensureCanMutateNextListeners() &#123; // &lt;-------这货就叫做【ensure 哥】吧 if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; /** * 返回 state */ function getState() &#123; return currentState &#125; /** * 负责注册回调函数的老司机 * * 这里需要注意的就是，回调函数中如果需要获取 state * 那每次获取都请使用 getState()，而不是开头用一个变量缓存住它 * 因为回调函数执行期间，有可能有连续几个 dispatch 让 state 改得物是人非 * 而且别忘了，dispatch 之后，整个 state 是被完全替换掉的 * 你缓存的 state 指向的可能已经是老掉牙的 state 了！！！ * * @param &#123;函数&#125; 想要订阅的回调函数 * @return &#123;函数&#125; 取消订阅的函数 */ function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; var isSubscribed = true ensureCanMutateNextListeners() // 调用 ensure 哥保平安 nextListeners.push(listener) // 新增订阅在 nextListeners 中操作 // 返回一个取消订阅的函数 return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() // 调用 ensure 哥保平安 var index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) // 取消订阅还是在 nextListeners 中操作 &#125; &#125; /** * 改变应用状态 state 的不二法门：dispatch 一个 action * 内部的实现是：往 reducer 中传入 currentState 以及 action * 用其返回值替换 currentState，最后逐个触发回调函数 * * 如果 dispatch 的不是一个对象类型的 action（同步的），而是 Promise / thunk（异步的） * 则需引入 redux-thunk 等中间件来反转控制权【悬念2：什么是反转控制权？】 * * @param &amp; @return &#123;对象&#125; action */ function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true // 关键点：currentState 与 action 会流通到所有的 reducer // 所有 reducer 的返回值整合后，替换掉当前的 currentState currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; // 令 currentListeners 等于 nextListeners，表示正在逐个执行回调函数（这就是上面 ensure 哥的判定条件） var listeners = currentListeners = nextListeners // 逐个触发回调函数 for (var i = 0; i &lt; listeners.length; i++) &#123; listeners[i]() /* 现在逐个触发回调函数变成了： var listener = listeners[i] listener() // 该中间变量避免了 this 指向 listeners 而造成泄露的问题 */ // 在此衷心感谢 @BuptStEve 在 issue7 中指出之前我对此处的错误解读 &#125; return action // 为了方便链式调用，dispatch 执行完毕后，返回 action（下文会提到的，稍微记住就好了） &#125; /** * 替换当前 reducer 的老司机 * 主要用于代码分离按需加载、热替换等情况 * * @param &#123;函数&#125; nextReducer */ function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer // 就是这么简单粗暴！ dispatch(&#123; type: ActionTypes.INIT &#125;) // 触发生成新的 state 树 &#125; /** * 这是留给 可观察/响应式库 的接口（详情 https://github.com/zenparsing/es-observable） * 如果您了解 RxJS 等响应式编程库，那可能会用到这个接口，否则请略过 * @return &#123;observable&#125; */ function observable() &#123;略&#125; // 这里 dispatch 只是为了生成 应用初始状态 dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 【悬念2：什么是反转控制权？ · 解疑】在同步场景下，dispatch(action) 的这个 action 中的数据是同步获取的，并没有控制权的切换问题但异步场景下，则需要将 dispatch 传入到回调函数。待异步操作完成后，回调函数自行调用 dispatch(action) 说白了：在异步 Action Creator 中自行调用 dispatch 就相当于反转控制权您完全可以自己实现，也可以借助 redux-thunk / redux-promise 等中间件统一实现（它们的作用也仅仅就是把 dispatch 等传入异步 Action Creator 罢了） 拓展阅读：阮老师的 Thunk 函数的含义与用法题外话：您不觉得 JavaScript 的回调函数，就是反转控制权最普遍的体现吗？ &sect; combineReducers(reducers)⊙ 应用场景简明教程中的 code-7 如下： 12345678910111213141516171819/** 本代码块记为 code-7 **/var initState = &#123; counter: 0, todos: []&#125;function reducer(state, action) &#123; if (!state) state = initState switch (action.type) &#123; case 'ADD_TODO': var nextState = _.cloneDeep(state) // 用到了 lodash 的深克隆 nextState.todos.push(action.payload) return nextState default: return state &#125;&#125; 上面的 reducer 仅仅是实现了 “新增待办事项” 的 state 的处理我们还有计数器的功能，下面我们继续增加计数器 “增加 1” 的功能： 1234567891011121314151617/** 本代码块记为 code-8 **/var initState = &#123; counter: 0, todos: [] &#125;function reducer(state, action) &#123; if (!state) return initState // 若是初始化可立即返回应用初始状态 var nextState = _.cloneDeep(state) // 否则二话不说先克隆 switch (action.type) &#123; case 'ADD_TODO': // 新增待办事项 nextState.todos.push(action.payload) break case 'INCREMENT': // 计数器加 1 nextState.counter = nextState.counter + 1 break &#125; return nextState&#125; 如果说还有其他的动作，都需要在 code-8 这个 reducer 中继续堆砌处理逻辑但我们知道，计数器 与 待办事项 属于两个不同的模块，不应该都堆在一起写如果之后又要引入新的模块（例如留言板），该 reducer 会越来越臃肿此时就是 combineReducers 大显身手的时刻： 12345目录结构如下reducers/ ├── index.js ├── counterReducer.js ├── todosReducer.js 123456789101112131415161718192021222324252627282930313233343536/** 本代码块记为 code-9 **//* reducers/index.js */import &#123; combineReducers &#125; from 'redux'import counterReducer from './counterReducer'import todosReducer from './todosReducer'const rootReducer = combineReducers(&#123; counter: counterReducer, // 键名就是该 reducer 对应管理的 state todos: todosReducer&#125;)export default rootReducer-------------------------------------------------/* reducers/counterReducer.js */export default function counterReducer(counter = 0, action) &#123; // 传入的 state 其实是 state.counter switch (action.type) &#123; case 'INCREMENT': return counter + 1 // counter 是值传递，因此可以直接返回一个值 default: return counter &#125;&#125;-------------------------------------------------/* reducers/todosReducers */export default function todosReducer(todos = [], action) &#123; // 传入的 state 其实是 state.todos switch (action.type) &#123; case 'ADD_TODO': return [ ...todos, action.payload ] default: return todos &#125;&#125; code-8 reducer 与 code-9 rootReducer 的功能是一样的，但后者的各个子 reducer 仅维护对应的那部分 state其可操作性、可维护性、可扩展性大大增强 Flux 中是根据不同的功能拆分出多个 store 分而治之而 Redux 只允许应用中有唯一的 store，通过拆分出多个 reducer 分别管理对应的 state 下面继续来深入使用 combineReducers。一直以来我们的应用状态都是只有两层，如下所示： 123state ├── counter: 0 ├── todos: [] 如果说现在又有一个需求：在待办事项模块中，存储用户每次操作（增删改）的时间，那么此时应用初始状态树应为： 12345state ├── counter: 0 ├── todo ├── optTime: [] ├── todoList: [] # 这其实就是原来的 todos！ 那么对应的 reducer 就是： 12345678目录结构如下reducers/ ├── index.js &lt;-------------- combineReducers (生成 rootReducer) ├── counterReducer.js ├── todoReducers/ ├── index.js &lt;------ combineReducers ├── optTimeReducer.js ├── todoListReducer.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* reducers/index.js */import &#123; combineReducers &#125; from 'redux'import counterReducer from './counterReducer'import todoReducers from './todoReducers/'const rootReducer = combineReducers(&#123; counter: counterReducer, todo: todoReducers&#125;)export default rootReducer=================================================/* reducers/todoReducers/index.js */import &#123; combineReducers &#125; from 'redux'import optTimeReducer from './optTimeReducer'import todoListReducer from './todoListReducer'const todoReducers = combineReducers(&#123; optTime: optTimeReducer, todoList: todoListReducer&#125;)export default todoReducers-------------------------------------------------/* reducers/todosReducers/optTimeReducer.js */export default function optTimeReducer(optTime = [], action) &#123; // 咦？这里怎么没有 switch-case 分支？谁说 reducer 就一定包含 switch-case 分支的？ return action.type.includes('TODO') ? [ ...optTime, new Date() ] : optTime&#125;-------------------------------------------------/* reducers/todosReducers/todoListReducer.js */export default function todoListReducer(todoList = [], action) &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...todoList, action.payload ] default: return todoList &#125;&#125; 无论您的应用状态树有多么的复杂，都可以通过逐层下分管理对应部分的 state： 12345678 counterReducer(counter, action) -------------------- counter ↗ ↘rootReducer(state, action) —→∑ ↗ optTimeReducer(optTime, action) ------ optTime ↘ nextState ↘—→∑ todo ↗ ↘ todoListReducer(todoList,action) ----- todoList ↗注：左侧表示 dispatch 分发流，∑ 表示 combineReducers；右侧表示各实体 reducer 的返回值，最后汇总整合成 nextState 看了上图，您应该能直观感受到为何取名为 reducer 了吧？把 state 分而治之，极大减轻开发与维护的难度 无论是 dispatch 哪个 action，都会流通所有的 reducer表面上看来，这样子很浪费性能，但 JavaScript 对于这种纯函数的调用是很高效率的，因此请尽管放心这也是为何 reducer 必须返回其对应的 state 的原因。否则整合状态树时，该 reducer 对应的键值就是 undefined ⊙ 源码分析 仅截取关键部分，毕竟有很大一部分都是类型检测警告 12345678910111213141516171819202122232425262728function combineReducers(reducers) &#123; var reducerKeys = Object.keys(reducers) var finalReducers = &#123;&#125; for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i] if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; var finalReducerKeys = Object.keys(finalReducers) // 返回合成后的 reducer return function combination(state = &#123;&#125;, action) &#123; var hasChanged = false var nextState = &#123;&#125; for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] // 获取当前子 state var nextStateForKey = reducer(previousStateForKey, action) // 执行各子 reducer 中获取子 nextState nextState[key] = nextStateForKey // 将子 nextState 挂载到对应的键名 hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 在此我的注释很少，因为代码写得实在是太过明了了，注释反而影响阅读作者 Dan 用了大量的 for 循环，的确有点不够优雅 &sect; bindActionCreators(actionCreators, dispatch) 这个 API 有点鸡肋，它无非就是做了这件事情：dispatch(ActionCreator(XXX)) ⊙ 源码分析12345678910111213141516171819/* 为 Action Creator 加装上自动 dispatch 技能 */function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args))&#125;export default function bindActionCreators(actionCreators, dispatch) &#123; // 省去一大坨类型判断 var keys = Object.keys(actionCreators) var boundActionCreators = &#123;&#125; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i] var actionCreator = actionCreators[key] if (typeof actionCreator === 'function') &#123; // 逐个装上自动 dispatch 技能 boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) &#125; &#125; return boundActionCreators&#125; ⊙ 应用场景简明教程中的 code-5 如下： 1234567891011&lt;--! 本代码块记为 code-5 --&gt;&lt;input id="todoInput" type="text" /&gt;&lt;button id="btn"&gt;提交&lt;/button&gt;&lt;script&gt;$('#btn').on('click', function() &#123; var content = $('#todoInput').val() // 获取输入框的值 var action = addTodo(content) // 执行 Action Creator 获得 action store.dispatch(action) // 手动显式 dispatch 一个 action&#125;)&lt;/script&gt; 我们看到，调用 addTodo 这个 Action Creator 后得到一个 action，之后又要手动 dispatch(action)如果是只有一个两个 Action Creator 还是可以接受，但如果有很多个那就显得有点重复了（其实我觉得不重复哈哈哈）这个时候我们就可以利用 bindActionCreators 实现自动 dispatch： 123456789101112131415&lt;input id="todoInput" type="text" /&gt;&lt;button id="btn"&gt;提交&lt;/button&gt;&lt;script&gt;// 全局引入 Redux、jQuery，同时 store 是全局变量var actionsCreators = Redux.bindActionCreators( &#123; addTodo: addTodo &#125;, store.dispatch // 传入 dispatch 函数)$('#btn').on('click', function() &#123; var content = $('#todoInput').val() actionCreators.addTodo(content) // 它会自动 dispatch&#125;)&lt;/script&gt; 综上，这个 API 没啥卵用，尤其是异步场景下，基本用不上 &sect; applyMiddleware(…middlewares) Redux 中文文档 高级 · Middleware 有提到中间件的演化由来 首先要理解何谓 Middleware，何谓 Enhancer ⊙ Middleware说白了，Redux 引入中间件机制，其实就是为了在 dispatch 前后，统一“做爱做的事”。。。诸如统一的日志记录、引入 thunk 统一处理异步 Action Creator 等都属于中间件下面是一个简单的打印动作前后 state 的中间件： 123456789101112131415161718192021222324252627282930/* 装逼写法 */const printStateMiddleware = (&#123; getState &#125;) =&gt; next =&gt; action =&gt; &#123; console.log('state before dispatch', getState()) let returnValue = next(action) console.log('state after dispatch', getState()) return returnValue&#125;-------------------------------------------------/* 降低逼格写法 */function printStateMiddleware(middlewareAPI) &#123; // 记为【锚点-1】，中间件内可用的 API return function (dispatch) &#123; // 记为【锚点-2】，传入上级中间件处理逻辑（若无则为原 store.dispatch） // 下面记为【锚点-3】，整个函数将会被传到下级中间件（如果有的话）作为它的 dispatch 参数 return function (action) &#123; // &lt;---------------------------------------------- 这货就叫做【中间件处理逻辑哥】吧 console.log('state before dispatch', middlewareAPI.getState()) var returnValue = dispatch(action) // 还记得吗，dispatch 的返回值其实还是 action console.log('state after dispatch', middlewareAPI.getState()) return returnValue // 将 action 返回给上一个中间件（实际上可以返回任意值，或不返回） // 在此衷心感谢 @zaleGZL 在 issue15 中指出之前我对此处的错误解读 &#125; &#125;&#125; ⊙ Store Enhancer说白了，Store 增强器就是对生成的 store API 进行改造，这是它与中间件最大的区别（中间件不修改 store 的 API）而改造 store 的 API 就要从它的缔造者 createStore 入手。例如，Redux 的 API applyMiddleware 就是一个 Store 增强器： 12345678910111213141516171819202122232425262728293031323334353637383940414243import compose from './compose' // 这货的作用其实就是 compose(f, g, h)(action) =&gt; f(g(h(action)))/* 传入一坨中间件 */export default function applyMiddleware(...middlewares) &#123; /* 传入 createStore */ return function(createStore) &#123; /* 返回一个函数签名跟 createStore 一模一样的函数，亦即返回的是一个增强版的 createStore */ return function(reducer, preloadedState, enhancer) &#123; // 用原 createStore 先生成一个 store，其包含 getState / dispatch / subscribe / replaceReducer 四个 API var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch // 指向原 dispatch var chain = [] // 存储中间件的数组 // 提供给中间件的 API（其实都是 store 的 API） var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; // 给中间件“装上” API，见上面 ⊙Middleware【降低逼格写法】的【锚点-1】 chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 串联所有中间件 dispatch = compose(...chain)(store.dispatch) // 例如，chain 为 [M3, M2, M1]，而 compose 是从右到左进行“包裹”的 // 那么，M1 的 dispatch 参数为 store.dispatch（见【降低逼格写法】的【锚点-2】） // 往后，M2 的 dispatch 参数为 M1 的中间件处理逻辑哥（见【降低逼格写法】的【锚点-3】） // 同样，M3 的 dispatch 参数为 M2 的中间件处理逻辑哥 // 最后，我们得到串联后的中间件链：M3(M2(M1(store.dispatch))) //（这种形式的串联类似于洋葱，可参考文末的拓展阅读：中间件的洋葱模型） // 在此衷心感谢 @ibufu 在 issue8 中指出之前我对此处的错误解读 return &#123; ...store, // store 的 API 中保留 getState / subsribe / replaceReducer dispatch // 新 dispatch 覆盖原 dispatch，往后调用 dispatch 就会触发 chain 内的中间件链式串联执行 &#125; &#125; &#125;&#125; 最终返回的虽然还是 store 的那四个 API，但其中的 dispatch 函数的功能被增强了，这就是所谓的 Store Enhancer ⊙ 综合应用 ( 在线演示 )123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="//cdn.bootcss.com/redux/3.5.2/redux.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;/** Action Creators */function inc() &#123; return &#123; type: 'INCREMENT' &#125;;&#125;function dec() &#123; return &#123; type: 'DECREMENT' &#125;;&#125;function reducer(state, action) &#123; state = state || &#123; counter: 0 &#125;; switch (action.type) &#123; case 'INCREMENT': return &#123; counter: state.counter + 1 &#125;; case 'DECREMENT': return &#123; counter: state.counter - 1 &#125;; default: return state; &#125;&#125;function printStateMiddleware(middlewareAPI) &#123; return function (dispatch) &#123; return function (action) &#123; console.log('dispatch 前：', middlewareAPI.getState()); var returnValue = dispatch(action); console.log('dispatch 后：', middlewareAPI.getState(), '\n'); return returnValue; &#125;; &#125;;&#125;var enhancedCreateStore = Redux.applyMiddleware(printStateMiddleware)(Redux.createStore);var store = enhancedCreateStore(reducer);store.dispatch(inc());store.dispatch(inc());store.dispatch(dec());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台输出： 12345678dispatch 前：&#123; counter: 0 &#125;dispatch 后：&#123; counter: 1 &#125;dispatch 前：&#123; counter: 1 &#125;dispatch 后：&#123; counter: 2 &#125;dispatch 前：&#123; counter: 2 &#125;dispatch 后：&#123; counter: 1 &#125; 实际上，上面生成 store 的代码可以更加优雅： 12345/** 本代码块记为 code-10 **/var store = Redux.createStore( reducer, Redux.applyMiddleware(printStateMiddleware)) 如果有多个中间件以及多个增强器，还可以这样写（请留意序号顺序）： 重温一下 createStore 完整的函数签名：function createStore(reducer, preloadedState, enhancer) 1234567891011121314151617/** 本代码块记为 code-11 **/import &#123; createStore, applyMiddleware, compose &#125; from 'redux'const store = createStore( reducer, preloadedState, // 可选，前后端同构的数据同步 compose( // 还记得吗？compose 是从右到左的哦！ applyMiddleware( // 这货也是 Store Enhancer 哦！但这是关乎中间件的增强器，必须置于 compose 执行链的最后 middleware1, middleware2, middleware3 ), enhancer3, enhancer2, enhancer1 )) 为什么会支持那么多种写法呢？在 createStore 的源码分析的开头部分，我省略了一些代码，现在奉上该压轴部分： 1234567891011121314151617181920/** 本代码块记为 code-12 **/if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; // 这里就是上面 code-10 的情况，只传入 reducer 和 Store Enhancer 这两个参数 enhancer = preloadedState preloadedState = undefined&#125;if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; // 存在 enhancer 就立即执行，返回增强版的 createStore &lt;--------- 记为【锚点 12-1】 return enhancer(createStore)(reducer, preloadedState)&#125;if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.')&#125;// 除 compose 外，createStore 竟然也在此为我们提供了书写的便利与自由度，实在是太体贴了 如果像 code-11 那样有多个 enhancer，则 code-12 【锚点 12-1】 中的代码会执行多次生成最终的超级增强版 store。最后，奉上 code-11 中 compose 内部的执行顺序示意图： 123456789101112131415161718192021原 createStore ———— │ ↓return enhancer1(createStore)(reducer, preloadedState, enhancer2) | ├———————→ createStore 增强版 1 │ ↓return enhancer2(createStore1)(reducer, preloadedState, enhancer3) | ├———————————→ createStore 增强版 1+2 │ ↓return enhancer3(createStore1+2)(reducer, preloadedState, applyMiddleware(m1,m2,m3)) | ├————————————————————→ createStore 增强版 1+2+3 │ ↓return appleMiddleware(m1,m2,m3)(createStore1+2+3)(reducer, preloadedState) | ├——————————————————————————————————→ 生成最终增强版 store &sect; 总结Redux 有五个 API，分别是： createStore(reducer, [initialState]) combineReducers(reducers) applyMiddleware(...middlewares) bindActionCreators(actionCreators, dispatch) compose(...functions) createStore 生成的 store 有四个 API，分别是： getState() dispatch(action) subscribe(listener) replaceReducer(nextReducer) 至此，若您已经理解上述 API 的作用机理，以及中间件与增强器的概念/区别本人将不胜荣幸，不妨点个 star 算是对我的赞赏如您对本教程有任何意见或改进的建议，欢迎 issue，我会尽快予您答复 最后奉上 React + Redux + React Router 的简易留言板实例：react-demo 拓展阅读：中间件的洋葱模型]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 介绍]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[这是篇对Hexo博客的编写，部署，设计的详细说明。 这是斜体 或 这也是斜体这是粗体这是加粗斜体这是删除线 一级标题二级标题三级标题四级标题五级标题六级标题行内形式：我的博客参考形式：[我的博客][1]，有一个很好的平台-简书[1]:https://www/lvguoying.com/ 自动链接：我的博客地址https://www/lvguoying.com/ 无序列表项1 无序列表项2 无序列表项3 在 Hexo 中插入图片，首先需要将图片放在 source/images/ 文件夹下，然后如下方式进行插入： 表头1 表头2 表头3 表头4 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐 默认左对齐 左对齐 居中对其 右对齐]]></content>
      <categories>
        <category>常事</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇Hexo博客，写点vue的基础环境安装]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%88%91%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-mac%E4%B8%8A%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言通过近来对多人的面试，发现大部分 vue开发者 只停留在代码搬运阶段，而对概念和实现原理一知半解，特用此文档，将 vue.js 高频面试题从 代码实现 到 原理分析 进行整理、解析。本文档也不仅仅限于vue前端面试使用，而是以vue实际开发遇到的问题为出发点，带你关注 vue开发 过程中需要注意的一个个知识点。也希望可以帮助您解决vue实际开发过程中的问题。 一.vue-cli依赖的 Node.js 环境安装下面介绍 Node.js 环境的安装：1、首先需要在 node.js 官网: node.js .下载下载对应的 Node 环境安装包。 2、然后打开安装包，一直点击 next 3、测试安装成功 打开 cmd 命令行，命令行输入：1node -v 出现版本号，说明可以使用 node 的包管理器 npm，下载资源包。 二、vue-cli 工程技术集合介绍问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么?1、vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。2、vue-router：vue官方推荐使用的路由框架。3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。5、vux等：一个专为vue设计的移动端UI组件库。6、创建一个emit.js文件，用于vue事件机制的管理。7、webpack：模块加载和vue-cli工程打包器。 问题二：vue-cli 工程常用的 npm 命令有哪些？下载 node_modules 资源包的命令1npm install 启动 vue-cli 开发环境的 npm命令：1npm run dev vue-cli 生成 生产环境部署资源 的 npm命令：1npm run build 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：1npm run build --report 此命令必答，可以加深面试官好感！ 三、vue-cli 工程目录结构介绍问题一：请说出vue-cli工程中每个文件夹和文件的用处(注意：此问题千万不要只解释一下 src 文件夹下每个文件夹的作用。) vue-cli目录解析：1.build 文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下 webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。2.config 文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下 config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。3.dist 文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。4.node_modules：存放npm命令下载的开发环境和生产环境的依赖包。5.src: 存放项目源码及需要引用的资源文件。6.src下assets：存放项目中需要用到的资源文件，css、js、images等。7.src下componets：存放vue开发中一些公共组件：header.vue、footer.vue等。8.src下emit：自己配置的vue集中式事件管理机制。9.src下router：vue-router vue路由的配置文件。10.src下service：自己配置的vue请求后台接口方法。11.src下page：存在vue页面组件的文件夹。12.src下util：存放vue开发过程中一些公共的.js方法。13.src下vuex：存放 vuex 为vue专门开发的状态管理器。14.src下app.vue：使用标签&lt;route-view&gt;&lt;/router-view&gt;渲染整个工程的.vue组件。15.src下main.js：vue-cli工程的入口文件。16.index.html：设置项目的一些meta头信息和提供&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;用于挂载 vue 节点。17.package.json：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。 问题二：config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置build 对象下 对于 生产环境 的配置： index：配置打包后入口.html文件的名称以及文件夹名称 assetsRoot：配置打包后生成的文件名称和路径 assetsPublicPath：配置 打包后 .html 引用静态资源的路径，一般要设置成 “./“ productionGzip：是否开发 gzip 压缩，以提升加载速度 dev 对象下 对于 开发环境 的配置： port：设置端口号 autoOpenBrowser：启动工程时，自动打开浏览器 proxyTable：vue设置的代理，用以解决 跨域 问题 问题三：请你详细介绍一些 package.json 里面的配置 scripts：npm run xxx 命令调用node执行的 .js 文件 dependencies：生产环境依赖包的名称和版本号，即这些依赖包都会打包进生产环境的JS文件里面 devDependencies：开发环境依赖包的名称和版本号，即这些依赖包只用于代码开发的时候，不会打包进生产环境js文件里面。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
